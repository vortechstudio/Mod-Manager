<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nvtt: nvtt::Surface Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">nvtt
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenvtt.html">nvtt</a></li><li class="navelem"><a class="el" href="structnvtt_1_1_surface.html">Surface</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structnvtt_1_1_surface-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">nvtt::Surface Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A surface is one level of a 2D or 3D texture.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="nvtt_8h_source.html">nvtt.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa10fea1a1aaaa80aab8c2f8912152ea6" id="r_aa10fea1a1aaaa80aab8c2f8912152ea6"><td class="memItemLeft" align="right" valign="top"><a id="aa10fea1a1aaaa80aab8c2f8912152ea6" name="aa10fea1a1aaaa80aab8c2f8912152ea6"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Surface</b> ()</td></tr>
<tr class="memdesc:aa10fea1a1aaaa80aab8c2f8912152ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty surface. All data will be null until a <a class="el" href="#a5a47935fcb94952c439aa5a4e4d4f498" title="Sets this surface to a new w x h x d uninitialized image.">setImage()</a> function is called. <br /></td></tr>
<tr class="separator:aa10fea1a1aaaa80aab8c2f8912152ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d9d59fbb2f903f3cb06d27a8b5c539" id="r_ab3d9d59fbb2f903f3cb06d27a8b5c539"><td class="memItemLeft" align="right" valign="top"><a id="ab3d9d59fbb2f903f3cb06d27a8b5c539" name="ab3d9d59fbb2f903f3cb06d27a8b5c539"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Surface</b> (const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;img)</td></tr>
<tr class="memdesc:ab3d9d59fbb2f903f3cb06d27a8b5c539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:ab3d9d59fbb2f903f3cb06d27a8b5c539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643c99ac5f1726e0a9396d89be2c4fb3" id="r_a643c99ac5f1726e0a9396d89be2c4fb3"><td class="memItemLeft" align="right" valign="top"><a id="a643c99ac5f1726e0a9396d89be2c4fb3" name="a643c99ac5f1726e0a9396d89be2c4fb3"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><b>~Surface</b> ()</td></tr>
<tr class="memdesc:a643c99ac5f1726e0a9396d89be2c4fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a643c99ac5f1726e0a9396d89be2c4fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079466281e2c845c167f57660d681970" id="r_a079466281e2c845c167f57660d681970"><td class="memItemLeft" align="right" valign="top"><a id="a079466281e2c845c167f57660d681970" name="a079466281e2c845c167f57660d681970"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;img)</td></tr>
<tr class="memdesc:a079466281e2c845c167f57660d681970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br /></td></tr>
<tr class="separator:a079466281e2c845c167f57660d681970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7715f4c5b9c06016055877dd31a39c99" id="r_a7715f4c5b9c06016055877dd31a39c99"><td class="memItemLeft" align="right" valign="top"><a id="a7715f4c5b9c06016055877dd31a39c99" name="a7715f4c5b9c06016055877dd31a39c99"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> <a class="el" href="structnvtt_1_1_surface.html">Surface</a>&#160;</td><td class="memItemRight" valign="bottom"><b>clone</b> () const</td></tr>
<tr class="memdesc:a7715f4c5b9c06016055877dd31a39c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of this <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a>, with its own internal data. (New in NVTT 3.1) <br /></td></tr>
<tr class="separator:a7715f4c5b9c06016055877dd31a39c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ce266053ecbb11a87835afa9acce54" id="r_a17ce266053ecbb11a87835afa9acce54"><td class="memItemLeft" align="right" valign="top"><a id="a17ce266053ecbb11a87835afa9acce54" name="a17ce266053ecbb11a87835afa9acce54"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>setWrapMode</b> (<a class="el" href="namespacenvtt.html#a04c40c16cdcde3c6c3f2e7081777a146">WrapMode</a> mode)</td></tr>
<tr class="memdesc:a17ce266053ecbb11a87835afa9acce54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a>'s wrap mode. See <a class="el" href="namespacenvtt.html#a04c40c16cdcde3c6c3f2e7081777a146" title="Wrap modes. Specifies how to handle coordinates outside the typical image range.">WrapMode</a> for details. <br /></td></tr>
<tr class="separator:a17ce266053ecbb11a87835afa9acce54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e64b40ae34367071fb703da3bf71c2" id="r_ae6e64b40ae34367071fb703da3bf71c2"><td class="memItemLeft" align="right" valign="top"><a id="ae6e64b40ae34367071fb703da3bf71c2" name="ae6e64b40ae34367071fb703da3bf71c2"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>setAlphaMode</b> (<a class="el" href="namespacenvtt.html#a258d3a85ebeb5cf05c98ce3b2441b172">AlphaMode</a> <a class="el" href="#a1ee2a5e77598e1801dbe683872fe1bae">alphaMode</a>)</td></tr>
<tr class="memdesc:ae6e64b40ae34367071fb703da3bf71c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a>'s alpha mode. See <a class="el" href="namespacenvtt.html#a258d3a85ebeb5cf05c98ce3b2441b172" title="Alpha mode.">AlphaMode</a> for details. <br /></td></tr>
<tr class="separator:ae6e64b40ae34367071fb703da3bf71c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ba609fa802c4685a9a488f8e5ef318" id="r_a35ba609fa802c4685a9a488f8e5ef318"><td class="memItemLeft" align="right" valign="top"><a id="a35ba609fa802c4685a9a488f8e5ef318" name="a35ba609fa802c4685a9a488f8e5ef318"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>setNormalMap</b> (bool <a class="el" href="#a625d336bfd75732460b6fa619116a178">isNormalMap</a>)</td></tr>
<tr class="memdesc:a35ba609fa802c4685a9a488f8e5ef318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether the <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> represents a normal map. This can be accessed using <a class="el" href="#a625d336bfd75732460b6fa619116a178" title="Returns whether the image represents a normal map. See setNormalMap()">isNormalMap()</a>, and e.g. affects whether DDS files are written with the normal map flag. <br /></td></tr>
<tr class="separator:a35ba609fa802c4685a9a488f8e5ef318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d06b99f9298acdcac222e8c48d49a0b" id="r_a3d06b99f9298acdcac222e8c48d49a0b"><td class="memItemLeft" align="right" valign="top"><a id="a3d06b99f9298acdcac222e8c48d49a0b" name="a3d06b99f9298acdcac222e8c48d49a0b"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>isNull</b> () const</td></tr>
<tr class="memdesc:a3d06b99f9298acdcac222e8c48d49a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the surface is null (i.e. refers to nothing, such as if it was just created using <a class="el" href="#aa10fea1a1aaaa80aab8c2f8912152ea6" title="Creates an empty surface. All data will be null until a setImage() function is called.">Surface()</a>). <br /></td></tr>
<tr class="separator:a3d06b99f9298acdcac222e8c48d49a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab766483595f4db56c7807bf0c81ed98c" id="r_ab766483595f4db56c7807bf0c81ed98c"><td class="memItemLeft" align="right" valign="top"><a id="ab766483595f4db56c7807bf0c81ed98c" name="ab766483595f4db56c7807bf0c81ed98c"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><b>width</b> () const</td></tr>
<tr class="memdesc:ab766483595f4db56c7807bf0c81ed98c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the width (X size) of the surface. <br /></td></tr>
<tr class="separator:ab766483595f4db56c7807bf0c81ed98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059d6eadb470e5b4209ad12e7c73309e" id="r_a059d6eadb470e5b4209ad12e7c73309e"><td class="memItemLeft" align="right" valign="top"><a id="a059d6eadb470e5b4209ad12e7c73309e" name="a059d6eadb470e5b4209ad12e7c73309e"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><b>height</b> () const</td></tr>
<tr class="memdesc:a059d6eadb470e5b4209ad12e7c73309e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the height (Y size) of the surface. <br /></td></tr>
<tr class="separator:a059d6eadb470e5b4209ad12e7c73309e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ceabda2b08248eecbe991b708ae52fb" id="r_a6ceabda2b08248eecbe991b708ae52fb"><td class="memItemLeft" align="right" valign="top"><a id="a6ceabda2b08248eecbe991b708ae52fb" name="a6ceabda2b08248eecbe991b708ae52fb"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><b>depth</b> () const</td></tr>
<tr class="memdesc:a6ceabda2b08248eecbe991b708ae52fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the depth (Z size) of the surface. 1 for 2D surfaces. <br /></td></tr>
<tr class="separator:a6ceabda2b08248eecbe991b708ae52fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d634b69971ab7e51897e08c0c1b54cc" id="r_a6d634b69971ab7e51897e08c0c1b54cc"><td class="memItemLeft" align="right" valign="top"><a id="a6d634b69971ab7e51897e08c0c1b54cc" name="a6d634b69971ab7e51897e08c0c1b54cc"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> <a class="el" href="namespacenvtt.html#a22da3a04bb7324cbd3919166b678b8e2">TextureType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>type</b> () const</td></tr>
<tr class="memdesc:a6d634b69971ab7e51897e08c0c1b54cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimensionality of the surface. This is set for instance by <a class="el" href="#a5a47935fcb94952c439aa5a4e4d4f498" title="Sets this surface to a new w x h x d uninitialized image.">setImage()</a>. <br /></td></tr>
<tr class="separator:a6d634b69971ab7e51897e08c0c1b54cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00cb3a6c63bf4381960e19681177cec" id="r_ad00cb3a6c63bf4381960e19681177cec"><td class="memItemLeft" align="right" valign="top"><a id="ad00cb3a6c63bf4381960e19681177cec" name="ad00cb3a6c63bf4381960e19681177cec"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> <a class="el" href="namespacenvtt.html#a04c40c16cdcde3c6c3f2e7081777a146">WrapMode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>wrapMode</b> () const</td></tr>
<tr class="memdesc:ad00cb3a6c63bf4381960e19681177cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the wrap mode of the surface. See <a class="el" href="#a17ce266053ecbb11a87835afa9acce54" title="Set the Surface&#39;s wrap mode. See WrapMode for details.">setWrapMode()</a> <br /></td></tr>
<tr class="separator:ad00cb3a6c63bf4381960e19681177cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee2a5e77598e1801dbe683872fe1bae" id="r_a1ee2a5e77598e1801dbe683872fe1bae"><td class="memItemLeft" align="right" valign="top"><a id="a1ee2a5e77598e1801dbe683872fe1bae" name="a1ee2a5e77598e1801dbe683872fe1bae"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> <a class="el" href="namespacenvtt.html#a258d3a85ebeb5cf05c98ce3b2441b172">AlphaMode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>alphaMode</b> () const</td></tr>
<tr class="memdesc:a1ee2a5e77598e1801dbe683872fe1bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the alpha mode of the surface. See <a class="el" href="#ae6e64b40ae34367071fb703da3bf71c2" title="Set the Surface&#39;s alpha mode. See AlphaMode for details.">setAlphaMode()</a> <br /></td></tr>
<tr class="separator:a1ee2a5e77598e1801dbe683872fe1bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625d336bfd75732460b6fa619116a178" id="r_a625d336bfd75732460b6fa619116a178"><td class="memItemLeft" align="right" valign="top"><a id="a625d336bfd75732460b6fa619116a178" name="a625d336bfd75732460b6fa619116a178"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>isNormalMap</b> () const</td></tr>
<tr class="memdesc:a625d336bfd75732460b6fa619116a178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the image represents a normal map. See <a class="el" href="#a35ba609fa802c4685a9a488f8e5ef318" title="Set whether the Surface represents a normal map. This can be accessed using isNormalMap(),...">setNormalMap()</a> <br /></td></tr>
<tr class="separator:a625d336bfd75732460b6fa619116a178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4de8d67b1fb1ac8a96ff1af239b436" id="r_a9d4de8d67b1fb1ac8a96ff1af239b436"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d4de8d67b1fb1ac8a96ff1af239b436">countMipmaps</a> () const</td></tr>
<tr class="memdesc:a9d4de8d67b1fb1ac8a96ff1af239b436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of mipmaps in a full mipmap chain. Each mip is half the size of the previous, rounding down, until and including a 1x1 mip.  <br /></td></tr>
<tr class="separator:a9d4de8d67b1fb1ac8a96ff1af239b436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f3fd4ea1fd7e31dcfc1d6a6f81ad4a" id="r_a85f3fd4ea1fd7e31dcfc1d6a6f81ad4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85f3fd4ea1fd7e31dcfc1d6a6f81ad4a">countMipmaps</a> (int min_size) const</td></tr>
<tr class="memdesc:a85f3fd4ea1fd7e31dcfc1d6a6f81ad4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of mipmaps in a mipmap chain, stopping when canMakeNextMipmap() returns false.  <br /></td></tr>
<tr class="separator:a85f3fd4ea1fd7e31dcfc1d6a6f81ad4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4cdb2773ea35b42ea460a2b4026cbe" id="r_a3b4cdb2773ea35b42ea460a2b4026cbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b4cdb2773ea35b42ea460a2b4026cbe">alphaTestCoverage</a> (float alphaRef=0.5, int alpha_channel=3) const</td></tr>
<tr class="memdesc:a3b4cdb2773ea35b42ea460a2b4026cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the approximate fraction (0 to 1) of the image with an alpha value greater than <code>alphaRef</code>.  <br /></td></tr>
<tr class="separator:a3b4cdb2773ea35b42ea460a2b4026cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ed55dcc5f3f3d297e02872164be2d5" id="r_ae9ed55dcc5f3f3d297e02872164be2d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9ed55dcc5f3f3d297e02872164be2d5">average</a> (int <a class="el" href="#a45354a15e70f6a2198cc43a01d3c2aa6">channel</a>, int alpha_channel=-1, float gamma=2.2f) const</td></tr>
<tr class="memdesc:ae9ed55dcc5f3f3d297e02872164be2d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a channel, possibly with alpha or with a gamma transfer function.  <br /></td></tr>
<tr class="separator:ae9ed55dcc5f3f3d297e02872164be2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c605957799d4ea31682d5982e1036d" id="r_a40c605957799d4ea31682d5982e1036d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> const float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40c605957799d4ea31682d5982e1036d">data</a> () const</td></tr>
<tr class="memdesc:a40c605957799d4ea31682d5982e1036d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code>const</code> pointer to the surface's CPU data.  <br /></td></tr>
<tr class="separator:a40c605957799d4ea31682d5982e1036d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45354a15e70f6a2198cc43a01d3c2aa6" id="r_a45354a15e70f6a2198cc43a01d3c2aa6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> const float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45354a15e70f6a2198cc43a01d3c2aa6">channel</a> (int i) const</td></tr>
<tr class="memdesc:a45354a15e70f6a2198cc43a01d3c2aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code>const</code> pointer to channel i's CPU data.  <br /></td></tr>
<tr class="separator:a45354a15e70f6a2198cc43a01d3c2aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad4388ee26550c4aae145b99d0ac563" id="r_acad4388ee26550c4aae145b99d0ac563"><td class="memItemLeft" align="right" valign="top"><a id="acad4388ee26550c4aae145b99d0ac563" name="acad4388ee26550c4aae145b99d0ac563"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> float *&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> ()</td></tr>
<tr class="memdesc:acad4388ee26550c4aae145b99d0ac563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer that can be used to modify the surface's CPU data. See <a class="el" href="#a40c605957799d4ea31682d5982e1036d" title="Returns a const pointer to the surface&#39;s CPU data.">data() const</a>. <br /></td></tr>
<tr class="separator:acad4388ee26550c4aae145b99d0ac563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0223344443b8ad809b76248e536c3245" id="r_a0223344443b8ad809b76248e536c3245"><td class="memItemLeft" align="right" valign="top"><a id="a0223344443b8ad809b76248e536c3245" name="a0223344443b8ad809b76248e536c3245"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> float *&#160;</td><td class="memItemRight" valign="bottom"><b>channel</b> (int i)</td></tr>
<tr class="memdesc:a0223344443b8ad809b76248e536c3245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer that can be used to modify channel i's CPU data. See <a class="el" href="#a45354a15e70f6a2198cc43a01d3c2aa6" title="Returns a const pointer to channel i&#39;s CPU data.">channel(int) const</a>. <br /></td></tr>
<tr class="separator:a0223344443b8ad809b76248e536c3245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315247163465480bfc38c9a63a4f4e3a" id="r_a315247163465480bfc38c9a63a4f4e3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a315247163465480bfc38c9a63a4f4e3a">histogram</a> (int <a class="el" href="#a45354a15e70f6a2198cc43a01d3c2aa6">channel</a>, float rangeMin, float rangeMax, int binCount, int *binPtr, TimingContext *tc=0) const</td></tr>
<tr class="memdesc:a315247163465480bfc38c9a63a4f4e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a histogram of channel values between <code>rangeMin</code> and <code>rangeMax</code> into <code>binPtr[0...binCount-1]</code>.  <br /></td></tr>
<tr class="separator:a315247163465480bfc38c9a63a4f4e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8a14675ef0cbc891bfe839d29a1c29" id="r_afc8a14675ef0cbc891bfe839d29a1c29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc8a14675ef0cbc891bfe839d29a1c29">range</a> (int <a class="el" href="#a45354a15e70f6a2198cc43a01d3c2aa6">channel</a>, float *rangeMin, float *rangeMax, int alpha_channel=-1, float alpha_ref=0.f, TimingContext *tc=0) const</td></tr>
<tr class="memdesc:afc8a14675ef0cbc891bfe839d29a1c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>*rangeMin</code> and <code>*rangeMax</code> to the range of values in the channel, possibly using alpha testing.  <br /></td></tr>
<tr class="separator:afc8a14675ef0cbc891bfe839d29a1c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7162b072976c0134a3854df107c2b7d5" id="r_a7162b072976c0134a3854df107c2b7d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7162b072976c0134a3854df107c2b7d5">load</a> (const char *fileName, bool *hasAlpha=0, bool expectSigned=false, TimingContext *tc=0)</td></tr>
<tr class="memdesc:a7162b072976c0134a3854df107c2b7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads texture data from a file.  <br /></td></tr>
<tr class="separator:a7162b072976c0134a3854df107c2b7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779543e6e00e503a8734b1281ff25b5b" id="r_a779543e6e00e503a8734b1281ff25b5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a779543e6e00e503a8734b1281ff25b5b">loadFromMemory</a> (const void *<a class="el" href="#a40c605957799d4ea31682d5982e1036d">data</a>, unsigned long long sizeInBytes, bool *hasAlpha=0, bool expectSigned=false, TimingContext *tc=0)</td></tr>
<tr class="memdesc:a779543e6e00e503a8734b1281ff25b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of <a class="el" href="#a7162b072976c0134a3854df107c2b7d5" title="Loads texture data from a file.">load()</a> that reads from memory instead of a file.  <br /></td></tr>
<tr class="separator:a779543e6e00e503a8734b1281ff25b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103d5b57c7153ceb77f23a3d9714c706" id="r_a103d5b57c7153ceb77f23a3d9714c706"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a103d5b57c7153ceb77f23a3d9714c706">save</a> (const char *fileName, bool hasAlpha=false, bool hdr=false, TimingContext *tc=0) const</td></tr>
<tr class="memdesc:a103d5b57c7153ceb77f23a3d9714c706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves texture data to file.  <br /></td></tr>
<tr class="separator:a103d5b57c7153ceb77f23a3d9714c706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a47935fcb94952c439aa5a4e4d4f498" id="r_a5a47935fcb94952c439aa5a4e4d4f498"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a47935fcb94952c439aa5a4e4d4f498">setImage</a> (int w, int h, int d, TimingContext *tc=0)</td></tr>
<tr class="memdesc:a5a47935fcb94952c439aa5a4e4d4f498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this surface to a new w x h x d uninitialized image.  <br /></td></tr>
<tr class="separator:a5a47935fcb94952c439aa5a4e4d4f498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f88d67c313490b2ed042c240b718c2" id="r_ab1f88d67c313490b2ed042c240b718c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1f88d67c313490b2ed042c240b718c2">setImage</a> (<a class="el" href="namespacenvtt.html#a7ea4cd82d5104d66e14f5524442c5f5e">InputFormat</a> format, int w, int h, int d, const void *<a class="el" href="#a40c605957799d4ea31682d5982e1036d">data</a>, bool unsignedToSigned=false, TimingContext *tc=0)</td></tr>
<tr class="memdesc:ab1f88d67c313490b2ed042c240b718c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this surface given uncompressed input data.  <br /></td></tr>
<tr class="separator:ab1f88d67c313490b2ed042c240b718c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6575c5667cd8654ee9d224075f5e3576" id="r_a6575c5667cd8654ee9d224075f5e3576"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6575c5667cd8654ee9d224075f5e3576">setImage</a> (<a class="el" href="namespacenvtt.html#a7ea4cd82d5104d66e14f5524442c5f5e">InputFormat</a> format, int w, int h, int d, const void *r, const void *g, const void *b, const void *a, TimingContext *tc=0)</td></tr>
<tr class="memdesc:a6575c5667cd8654ee9d224075f5e3576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this surface given uncompressed input data, with different pointers for each channel.  <br /></td></tr>
<tr class="separator:a6575c5667cd8654ee9d224075f5e3576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a687a3504eeba283366e36315904aeb" id="r_a4a687a3504eeba283366e36315904aeb"><td class="memItemLeft" align="right" valign="top"><a id="a4a687a3504eeba283366e36315904aeb" name="a4a687a3504eeba283366e36315904aeb"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>setImage2D</b> (<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6d">Format</a> format, int w, int h, const void *<a class="el" href="#a40c605957799d4ea31682d5982e1036d">data</a>, TimingContext *tc=0)</td></tr>
<tr class="memdesc:a4a687a3504eeba283366e36315904aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set 2D surface values from an encoded data source. Same as <a class="el" href="#a2aed8c61f05336b7eab8b2e1431ccc65" title="Set surface values from an encoded data source.">setImage3D()</a> with <code>d=1</code>. <br /></td></tr>
<tr class="separator:a4a687a3504eeba283366e36315904aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aed8c61f05336b7eab8b2e1431ccc65" id="r_a2aed8c61f05336b7eab8b2e1431ccc65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2aed8c61f05336b7eab8b2e1431ccc65">setImage3D</a> (<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6d">Format</a> format, int w, int h, int d, const void *<a class="el" href="#a40c605957799d4ea31682d5982e1036d">data</a>, TimingContext *tc=0)</td></tr>
<tr class="memdesc:a2aed8c61f05336b7eab8b2e1431ccc65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set surface values from an encoded data source.  <br /></td></tr>
<tr class="separator:a2aed8c61f05336b7eab8b2e1431ccc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b2bd544a72fb7c60e0106c6f870893" id="r_aa8b2bd544a72fb7c60e0106c6f870893"><td class="memItemLeft" align="right" valign="top"><a id="aa8b2bd544a72fb7c60e0106c6f870893" name="aa8b2bd544a72fb7c60e0106c6f870893"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>resize</b> (int w, int h, int d, <a class="el" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7">ResizeFilter</a> filter, TimingContext *tc=0)</td></tr>
<tr class="memdesc:aa8b2bd544a72fb7c60e0106c6f870893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes this surface to have size w x h x d using a given filter. <br /></td></tr>
<tr class="separator:aa8b2bd544a72fb7c60e0106c6f870893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013d651c695516e8fdbdf7634573918a" id="r_a013d651c695516e8fdbdf7634573918a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a013d651c695516e8fdbdf7634573918a">resize</a> (int w, int h, int d, <a class="el" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7">ResizeFilter</a> filter, float filterWidth, const float *params=0, TimingContext *tc=0)</td></tr>
<tr class="separator:a013d651c695516e8fdbdf7634573918a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac459aa4c41f41ec0f615b6352e3262c2" id="r_ac459aa4c41f41ec0f615b6352e3262c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac459aa4c41f41ec0f615b6352e3262c2">resize</a> (int maxExtent, <a class="el" href="namespacenvtt.html#a673a22796ec42ae50e14ab1ed6906bd5">RoundMode</a> mode, <a class="el" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7">ResizeFilter</a> filter, TimingContext *tc=0)</td></tr>
<tr class="memdesc:ac459aa4c41f41ec0f615b6352e3262c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes this surface so that its largest side has length <code>maxExtent</code>, subject to a rounding mode.  <br /></td></tr>
<tr class="separator:ac459aa4c41f41ec0f615b6352e3262c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f66cd503c0b7fd8667cfc7acca170e4" id="r_a6f66cd503c0b7fd8667cfc7acca170e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f66cd503c0b7fd8667cfc7acca170e4">resize</a> (int maxExtent, <a class="el" href="namespacenvtt.html#a673a22796ec42ae50e14ab1ed6906bd5">RoundMode</a> mode, <a class="el" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7">ResizeFilter</a> filter, float filterWidth, const float *params=0, TimingContext *tc=0)</td></tr>
<tr class="memdesc:a6f66cd503c0b7fd8667cfc7acca170e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes this surface so that its largest side has length <code>maxExtent</code>, subject to a rounding mode, using customizable filter parameters.  <br /></td></tr>
<tr class="separator:a6f66cd503c0b7fd8667cfc7acca170e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84c67783861084298893fa54f031624" id="r_af84c67783861084298893fa54f031624"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af84c67783861084298893fa54f031624">resize_make_square</a> (int maxExtent, <a class="el" href="namespacenvtt.html#a673a22796ec42ae50e14ab1ed6906bd5">RoundMode</a> roundMode, <a class="el" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7">ResizeFilter</a> filter, TimingContext *tc=0)</td></tr>
<tr class="memdesc:af84c67783861084298893fa54f031624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes this surface so that its longest side has length <code>maxExtent</code> and the result is square or cubical.  <br /></td></tr>
<tr class="separator:af84c67783861084298893fa54f031624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85e9ae8132a60fcf923300687af2778" id="r_ab85e9ae8132a60fcf923300687af2778"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab85e9ae8132a60fcf923300687af2778">buildNextMipmap</a> (<a class="el" href="namespacenvtt.html#a28d4701da3f4e6935956949dab69c479">MipmapFilter</a> filter, int min_size=1, TimingContext *tc=0)</td></tr>
<tr class="memdesc:ab85e9ae8132a60fcf923300687af2778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes this surface to create the next mip in a mipmap chain.  <br /></td></tr>
<tr class="separator:ab85e9ae8132a60fcf923300687af2778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbedd7b081d94ca7641d33453c3b96ed" id="r_afbedd7b081d94ca7641d33453c3b96ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbedd7b081d94ca7641d33453c3b96ed">buildNextMipmap</a> (<a class="el" href="namespacenvtt.html#a28d4701da3f4e6935956949dab69c479">MipmapFilter</a> filter, float filterWidth, const float *params=0, int min_size=1, TimingContext *tc=0)</td></tr>
<tr class="memdesc:afbedd7b081d94ca7641d33453c3b96ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <a class="el" href="#ab85e9ae8132a60fcf923300687af2778" title="Resizes this surface to create the next mip in a mipmap chain.">buildNextMipmap(MipmapFilter, int, TimingContext*)</a> with customizable parameters.  <br /></td></tr>
<tr class="separator:afbedd7b081d94ca7641d33453c3b96ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d48d0db77b102facf116ceb2d751371" id="r_a4d48d0db77b102facf116ceb2d751371"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d48d0db77b102facf116ceb2d751371">buildNextMipmapSolidColor</a> (const float *const color_components, TimingContext *tc=0)</td></tr>
<tr class="memdesc:a4d48d0db77b102facf116ceb2d751371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces this surface with a surface the size of the next mip in a mip chain (half the width and height), but with each channel cleared to a constant value.  <br /></td></tr>
<tr class="separator:a4d48d0db77b102facf116ceb2d751371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5328cdb2d5bf98aeece3a19b8addf0" id="r_a3d5328cdb2d5bf98aeece3a19b8addf0"><td class="memItemLeft" align="right" valign="top"><a id="a3d5328cdb2d5bf98aeece3a19b8addf0" name="a3d5328cdb2d5bf98aeece3a19b8addf0"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>canvasSize</b> (int w, int h, int d, TimingContext *tc=0)</td></tr>
<tr class="memdesc:a3d5328cdb2d5bf98aeece3a19b8addf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crops or expands this surface from the (0,0,0) corner, with any new values cleared to 0. <br /></td></tr>
<tr class="separator:a3d5328cdb2d5bf98aeece3a19b8addf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ecbc4dfdfcf7e02d3b94c536ebb4a83" id="r_a2ecbc4dfdfcf7e02d3b94c536ebb4a83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ecbc4dfdfcf7e02d3b94c536ebb4a83">GetRecord</a> (int i, char *outDescription, size_t outDescriptionSize, double &amp;outSeconds)</td></tr>
<tr class="memdesc:a2ecbc4dfdfcf7e02d3b94c536ebb4a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a the surface would have a next mip in a mip chain with minimum size <code>min_size. / / That is, it returns false if this surface has size 1x1x1, or if / the width and height are less than</code>min_size` and the depth is 1. NVTT_API bool canMakeNextMipmap(int min_size = 1);.  <br /></td></tr>
<tr class="separator:a2ecbc4dfdfcf7e02d3b94c536ebb4a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9324376c151d2aa91b23c402e150efe" id="r_aa9324376c151d2aa91b23c402e150efe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9324376c151d2aa91b23c402e150efe">PrintRecords</a> ()</td></tr>
<tr class="memdesc:aa9324376c151d2aa91b23c402e150efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints all records including their levels of nesting.  <br /></td></tr>
<tr class="separator:aa9324376c151d2aa91b23c402e150efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a7c44bc9884c2beb1058825a4afae765d" id="r_a7c44bc9884c2beb1058825a4afae765d"><td class="memItemLeft" align="right" valign="top"><a id="a7c44bc9884c2beb1058825a4afae765d" name="a7c44bc9884c2beb1058825a4afae765d"></a>
Private *&#160;</td><td class="memItemRight" valign="bottom"><b>m</b></td></tr>
<tr class="separator:a7c44bc9884c2beb1058825a4afae765d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A surface is one level of a 2D or 3D texture. </p>
<p>A surface has four channels numbered 0-3, also referred to as the red, green, blue, and alpha channels.</p>
<p>Surfaces store some additional properties, such as their width, height, depth, wrap mode, alpha mode, and whether they represent a normal map.</p>
<p>Surfaces can have CPU and GPU data. If a surface has GPU data, it always has CPU data. When the surface is GPU-enabled (using ToGPU()), image processing will be CUDA-accelerated and work on this GPU data. Calling ToCPU() will copy the GPU data to the CPU and destroy the GPU data buffer. <code>gpuData() != nullptr</code> can be used to determine if a surface has GPU data.</p>
<p>To directly access CPU data, use <a class="el" href="#acad4388ee26550c4aae145b99d0ac563" title="Returns a pointer that can be used to modify the surface&#39;s CPU data. See data() const.">data()</a> or <a class="el" href="#a45354a15e70f6a2198cc43a01d3c2aa6" title="Returns a const pointer to channel i&#39;s CPU data.">channel()</a>. To get a pointer to the GPU data buffer, use gpuData() (for a const CUDA pointer) or gpuDataMutable() (for a CUDA pointer to modifiable data).</p>
<p>Texture data is stored non-interleaved; that is, all channel 0's data is stored first, followed by channel 1's, and so on.</p>
<dl class="section note"><dt>Note</dt><dd>Performance note: Surfaces use reference-counted pointers to image data. This means that multiple Surfaces can reference the same data. This is handled automatically by NVTT's image processing routines. For instance, after the following piece of code, <div class="fragment"><div class="line"><a class="code hl_struct" href="structnvtt_1_1_surface.html">nvtt::Surface</a> s1;</div>
<div class="line">s1.<a class="code hl_function" href="#a5a47935fcb94952c439aa5a4e4d4f498">setImage</a>(...);</div>
<div class="line"><a class="code hl_struct" href="structnvtt_1_1_surface.html">nvtt::Surface</a> s2 = s1;</div>
<div class="ttc" id="astructnvtt_1_1_surface_html"><div class="ttname"><a href="structnvtt_1_1_surface.html">nvtt::Surface</a></div><div class="ttdoc">A surface is one level of a 2D or 3D texture.</div><div class="ttdef"><b>Definition</b> nvtt.h:698</div></div>
<div class="ttc" id="astructnvtt_1_1_surface_html_a5a47935fcb94952c439aa5a4e4d4f498"><div class="ttname"><a href="#a5a47935fcb94952c439aa5a4e4d4f498">nvtt::Surface::setImage</a></div><div class="ttdeci">NVTT_API bool setImage(int w, int h, int d, TimingContext *tc=0)</div><div class="ttdoc">Sets this surface to a new w x h x d uninitialized image.</div></div>
</div><!-- fragment --> surfaces <code>s1</code> and <code>s2</code> will have the same <code><a class="el" href="#acad4388ee26550c4aae145b99d0ac563" title="Returns a pointer that can be used to modify the surface&#39;s CPU data. See data() const.">data()</a></code> pointer. Cloning the underlying data is handled automatically: for instance, after <div class="fragment"><div class="line">s2.toSrgb()</div>
</div><!-- fragment --> <code>s2</code> will have a new <code><a class="el" href="#acad4388ee26550c4aae145b99d0ac563" title="Returns a pointer that can be used to modify the surface&#39;s CPU data. See data() const.">data()</a></code> pointer, and <code>s1</code> will be unchanged. This usually means that when writing custom image processing routines, you'll want to call <a class="el" href="#a7715f4c5b9c06016055877dd31a39c99" title="Creates a deep copy of this Surface, with its own internal data. (New in NVTT 3.1)">Surface::clone()</a> before modifying the <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a>'s data. Using Nsight Systems is one way to detect when additional allocations occur.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>NVTT 2.1 </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a3b4cdb2773ea35b42ea460a2b4026cbe" name="a3b4cdb2773ea35b42ea460a2b4026cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b4cdb2773ea35b42ea460a2b4026cbe">&#9670;&#160;</a></span>alphaTestCoverage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> float nvtt::Surface::alphaTestCoverage </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>alphaRef</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.5</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>alpha_channel</em></span><span class="paramdefsep"> = </span><span class="paramdefval">3</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the approximate fraction (0 to 1) of the image with an alpha value greater than <code>alphaRef</code>. </p>
<p>This function uses 8 x 8 subsampling together with linear interpolation.</p>
<dl class="section note"><dt>Note</dt><dd><code>alphaRef</code> is clamped to the range [1/256, 255/256]. </dd></dl>

</div>
</div>
<a id="ae9ed55dcc5f3f3d297e02872164be2d5" name="ae9ed55dcc5f3f3d297e02872164be2d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ed55dcc5f3f3d297e02872164be2d5">&#9670;&#160;</a></span>average()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> float nvtt::Surface::average </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>channel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>alpha_channel</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>gamma</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2.2f</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the average of a channel, possibly with alpha or with a gamma transfer function. </p>
<p>If <code>alpha_channel</code> is -1, this function computes</p>
<p><code>(sum(c[i]^gamma, i=0...numPixels)/numPixels)^(1/gamma)</code></p>
<p>where <code>c</code> is the channel's data.</p>
<p>Otherwise, this computes</p>
<p><code>(sum((c[i]^gamma) * a[i], i=0...numPixels)/sum(a[i], i=0...numPixels))^(1/gamma)</code></p>
<p>where <code>a</code> is the alpha channel's data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The channel to average. </td></tr>
    <tr><td class="paramname">alpha_channel</td><td>If not equal to -1, weights each texel's value after gamma correction by this channel. </td></tr>
    <tr><td class="paramname">gamma</td><td>Gamma for the transfer function to apply. A value of 2.2f roughly corresponds to averaging an sRGB image in linear space, then converting back to sRGB. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbedd7b081d94ca7641d33453c3b96ed" name="afbedd7b081d94ca7641d33453c3b96ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbedd7b081d94ca7641d33453c3b96ed">&#9670;&#160;</a></span>buildNextMipmap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool nvtt::Surface::buildNextMipmap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenvtt.html#a28d4701da3f4e6935956949dab69c479">MipmapFilter</a></td>          <td class="paramname"><span class="paramname"><em>filter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>filterWidth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *</td>          <td class="paramname"><span class="paramname"><em>params</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>min_size</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TimingContext *</td>          <td class="paramname"><span class="paramname"><em>tc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Version of <a class="el" href="#ab85e9ae8132a60fcf923300687af2778" title="Resizes this surface to create the next mip in a mipmap chain.">buildNextMipmap(MipmapFilter, int, TimingContext*)</a> with customizable parameters. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenvtt.html#a28d4701da3f4e6935956949dab69c479" title="Mipmap downsampling filters. Each of these can be customized using filterWidth and params when callin...">MipmapFilter</a> for the effects of different parameters. </dd></dl>

</div>
</div>
<a id="ab85e9ae8132a60fcf923300687af2778" name="ab85e9ae8132a60fcf923300687af2778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85e9ae8132a60fcf923300687af2778">&#9670;&#160;</a></span>buildNextMipmap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool nvtt::Surface::buildNextMipmap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenvtt.html#a28d4701da3f4e6935956949dab69c479">MipmapFilter</a></td>          <td class="paramname"><span class="paramname"><em>filter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>min_size</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TimingContext *</td>          <td class="paramname"><span class="paramname"><em>tc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes this surface to create the next mip in a mipmap chain. </p>
<p>Returns false iff the next mip would have been smaller than <code>min_size</code> (signaling the end of the mipmap chain). </p>

</div>
</div>
<a id="a4d48d0db77b102facf116ceb2d751371" name="a4d48d0db77b102facf116ceb2d751371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d48d0db77b102facf116ceb2d751371">&#9670;&#160;</a></span>buildNextMipmapSolidColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool nvtt::Surface::buildNextMipmapSolidColor </td>
          <td>(</td>
          <td class="paramtype">const float *const</td>          <td class="paramname"><span class="paramname"><em>color_components</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TimingContext *</td>          <td class="paramname"><span class="paramname"><em>tc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces this surface with a surface the size of the next mip in a mip chain (half the width and height), but with each channel cleared to a constant value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color_components</td><td>is an array of the value for each channel; it must be at least as long as the number of channels in the surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45354a15e70f6a2198cc43a01d3c2aa6" name="a45354a15e70f6a2198cc43a01d3c2aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45354a15e70f6a2198cc43a01d3c2aa6">&#9670;&#160;</a></span>channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> const float * nvtt::Surface::channel </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <code>const</code> pointer to channel i's CPU data. </p>
<p>Data is stored in [z, y, x] order; that is, all channel 0's data comes first, followed by all channel 1's data, and so on. More specifically, the value of channel c of the texel at (x, y, z) is at index</p>
<p><code>(z * <a class="el" href="#a059d6eadb470e5b4209ad12e7c73309e" title="Returns the height (Y size) of the surface.">height()</a> + y) * <a class="el" href="#ab766483595f4db56c7807bf0c81ed98c" title="Returns the width (X size) of the surface.">width()</a> + x</code></p>
<p>of channel(c).</p>
<dl class="section note"><dt>Note</dt><dd>If the image has GPU data (see ToGPU()), this performs a GPU-to-CPU copy. </dd></dl>

</div>
</div>
<a id="a9d4de8d67b1fb1ac8a96ff1af239b436" name="a9d4de8d67b1fb1ac8a96ff1af239b436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d4de8d67b1fb1ac8a96ff1af239b436">&#9670;&#160;</a></span>countMipmaps() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> int nvtt::Surface::countMipmaps </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of mipmaps in a full mipmap chain. Each mip is half the size of the previous, rounding down, until and including a 1x1 mip. </p>
<p>For instance, a 8x5 surface has mipmaps of size 8x5 (mip 0), 4x2 (mip 1), 2x1 (mip 2), and 1x1 (mip 3), so <a class="el" href="#a9d4de8d67b1fb1ac8a96ff1af239b436" title="Returns the number of mipmaps in a full mipmap chain. Each mip is half the size of the previous,...">countMipmaps()</a> returns 4. A 7x3 surface has mipmaps of size 7x3, 3x1, and 1x1, so <a class="el" href="#a9d4de8d67b1fb1ac8a96ff1af239b436" title="Returns the number of mipmaps in a full mipmap chain. Each mip is half the size of the previous,...">countMipmaps()</a> returns 3. </p>

</div>
</div>
<a id="a85f3fd4ea1fd7e31dcfc1d6a6f81ad4a" name="a85f3fd4ea1fd7e31dcfc1d6a6f81ad4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f3fd4ea1fd7e31dcfc1d6a6f81ad4a">&#9670;&#160;</a></span>countMipmaps() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> int nvtt::Surface::countMipmaps </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>min_size</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of mipmaps in a mipmap chain, stopping when canMakeNextMipmap() returns false. </p>
<p>That is, it stops when a 1x1x1 mip is reached if <code>min_size == 1</code> (in which case it is the same as <a class="el" href="#a9d4de8d67b1fb1ac8a96ff1af239b436" title="Returns the number of mipmaps in a full mipmap chain. Each mip is half the size of the previous,...">countMipmaps()</a>), or stops when the width and height are less than <code>min_size</code> and the depth is 1.</p>
<dl class="section see"><dt>See also</dt><dd>canMakeNextMipmap(). </dd></dl>

</div>
</div>
<a id="a40c605957799d4ea31682d5982e1036d" name="a40c605957799d4ea31682d5982e1036d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c605957799d4ea31682d5982e1036d">&#9670;&#160;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> const float * nvtt::Surface::data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <code>const</code> pointer to the surface's CPU data. </p>
<p>Data is stored in [c, z, y, x] order; that is, all channel 0's data comes first, followed by all channel 1's data, and so on. More specifically, the value of channel c of the texel at (x, y, z) is at index</p>
<p><code>((c * <a class="el" href="#a6ceabda2b08248eecbe991b708ae52fb" title="Returns the depth (Z size) of the surface. 1 for 2D surfaces.">depth()</a> + z) * <a class="el" href="#a059d6eadb470e5b4209ad12e7c73309e" title="Returns the height (Y size) of the surface.">height()</a> + y) * <a class="el" href="#ab766483595f4db56c7807bf0c81ed98c" title="Returns the width (X size) of the surface.">width()</a> + x</code>.</p>
<dl class="section note"><dt>Note</dt><dd>If the image has GPU data (see ToGPU()), this performs a GPU-to-CPU copy. </dd></dl>

</div>
</div>
<a id="a2ecbc4dfdfcf7e02d3b94c536ebb4a83" name="a2ecbc4dfdfcf7e02d3b94c536ebb4a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ecbc4dfdfcf7e02d3b94c536ebb4a83">&#9670;&#160;</a></span>GetRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> size_t nvtt::Surface::GetRecord </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>outDescription</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>outDescriptionSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>outSeconds</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether a the surface would have a next mip in a mip chain with minimum size <code>min_size. / / That is, it returns false if this surface has size 1x1x1, or if / the width and height are less than</code>min_size` and the depth is 1. NVTT_API bool canMakeNextMipmap(int min_size = 1);. </p>
<p>/ Raises channels 0...2 to the power <code>gamma</code>. / / <code>gamma=2.2</code> approximates sRGB-to-linear conversion. / / </p><dl class="section see"><dt>See also</dt><dd>toGamma() / </dd>
<dd>
toLinearFromSrgb() <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void toLinear(float gamma, TimingContext *tc = 0); / Raises channels 0...2 to the power <code>1/gamma</code>. / / <code>gamma=2.2</code> approximates linear-to-sRGB conversion. / / </dd>
<dd>
toLinear() / </dd>
<dd>
toSrgb() <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void toGamma(float gamma, TimingContext *tc = 0); / Raises the given <a class="el" href="#a45354a15e70f6a2198cc43a01d3c2aa6" title="Returns a const pointer to channel i&#39;s CPU data.">channel</a> to the power <code>gamma</code>. / </dd>
<dd>
toLinear(float, TimingContext*) <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void toLinear(int <a class="el" href="#a45354a15e70f6a2198cc43a01d3c2aa6" title="Returns a const pointer to channel i&#39;s CPU data.">channel</a>, float gamma, TimingContext *tc = 0); / Raises the given <a class="el" href="#a45354a15e70f6a2198cc43a01d3c2aa6" title="Returns a const pointer to channel i&#39;s CPU data.">channel</a> to the power <code>1/gamma</code>. / </dd>
<dd>
toGamma(float, TimingContext*) <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void toGamma(int <a class="el" href="#a45354a15e70f6a2198cc43a01d3c2aa6" title="Returns a const pointer to channel i&#39;s CPU data.">channel</a>, float gamma, TimingContext *tc = 0); / Applies the linear-to-sRGB transfer function to channels 0...2. / / This transfer function replaces each value <code>x</code> with / <code>text / if x is NaN or x &lt;= 0.0f, 0.0f / if x &lt;= 0.0031308f, 12.92f * x / if x &lt; 1.0f, powf(x, 1.0f/2.4f) * 1.055f - 0.055f / otherwise, 1.0f /</code> / / </dd>
<dd>
toLinearFromSrgb() <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void toSrgb(TimingContext *tc = 0); / Applies the linear-to-sRGB transfer function to channels 0...2, but does not clamp output to [0,1]. / / The motivation for this function is that it can approximately / preserve HDR values through sRGB conversion and back; that is, / s.toSrgbUnclamped().toLinearFromSrgbUnclamped() is close to s. / / This transfer function replaces each value <code>x</code> with / <code>text / if x is NaN or x &lt;= 0.0f, x / if x &lt;= 0.0031308f, 12.92f * x / otherwise, powf(x, 1.0f/2.4f) * 1.055f - 0.055f /</code> / / </dd></dl>
<dl class="section since"><dt>Since</dt><dd>NVTT 3.2 / </dd></dl>
<dl class="section see"><dt>See also</dt><dd>toLinearFromSrgbUnclamped() <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void toSrgbUnclamped(TimingContext *tc = 0); / Applies the sRGB-to-linear transfer function to channels 0...2. / / This transfer function replaces each value <code>x</code> with / <code>text / if x &lt; 0.0f, 0.0f / if x &lt; 0.04045f, x / 12.92f / if x &lt; 1.0f, powf((x + 0.055f)/1.055f, 2.4f) / otherwise, 1.0f /</code> / / </dd>
<dd>
toSrgb() <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void toLinearFromSrgb(TimingContext *tc = 0); / Applies the sRGB-to-linear transfer function to channels 0...2, but does not clamp output to [0,1]. / / The motivation for this function is that it can approximately / preserve HDR values through sRGB conversion and back; that is, / s.toSrgbUnclamped().toLinearFromSrgbUnclamped() is close to s. / / This transfer function replaces each value <code>x</code> with / <code>text / if x is NaN or x &lt;= 0.0f, x / if x &lt; 0.04045f, x / 12.92f / otherwise, powf((x + 0.055f)/1.055f, 2.4f) /</code> / / </dd></dl>
<dl class="section since"><dt>Since</dt><dd>NVTT 3.2 / </dd></dl>
<dl class="section see"><dt>See also</dt><dd>toSrgbUnclamped() <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void toLinearFromSrgbUnclamped(TimingContext *tc = 0); / Converts colors in channels 0...2 from linear to a / piecewise linear sRGB approximation. / / This transfer function replaces each value <code>x</code> with / <code>text / if x &lt; 0, 0.0f / if x &lt; 1/16, 4.0f * x / if x &lt; 1/8, 2.0f * x + 0.125f / if x &lt; 1/2, x + 0.25f / if x &lt; 1, 0.5f * x + 0.5f / otherwise, 1.0f /</code> / / </dd>
<dd>
Alex Vlachos, Post Processing in The Orange Box, GDC 2008 / </dd>
<dd>
toLinearFromXenonSrgb() <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void toXenonSrgb(TimingContext *tc = 0); / Converts colors in channels 0...2 from the Xenon sRGB / piecewise linear sRGB approximation to linear. / / This transfer function replaces each value <code>x</code> with / <code>text / if x &lt; 0, 0.0f / if x &lt; 1/4, x/4.0f / if x &lt; 3/8, (x - 0.125f) / 2.0f / if x &lt; 3/4, x - 0.25f / if x &lt; 1, (x - 0.5f) / 0.5f / otherwise, 1.0f /</code> / / </dd></dl>
<dl class="section since"><dt>Since</dt><dd>NVTT 3.2 / </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Alex Vlachos, Post Processing in The Orange Box, GDC 2008 / </dd>
<dd>
toXenonSrgb() <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void toLinearFromXenonSrgb(TimingContext *tc = 0); / Applies a 4x4 affine transformation to the values in channels 0...3. / / <code>w0</code>...<code>w3</code> are the columns of the matrix. <code>offset</code> is added after / the matrix-vector multiplication. / / In other words, all (r, g, b, a) values are replaced with / <code>text / (r) (w0[0], w1[0], w2[0], w3[0]) (r) (offset[0]) / (g) = (w0[1], w1[1], w2[1], w3[1]) (g) + (offset[1]) / (b) (w0[2], w1[2], w2[2], w3[2]) (b) (offset[2]) / (a) (w0[3], w1[3], w2[3], w3[3]) (a) (offset[3]) /</code> <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void transform(const float w0[4], const float w1[4], const float w2[4], const float w3[4], const float offset[4], TimingContext *tc = 0); / Swizzles the channels of the surface. / / Each argument specifies where the corresponding <a class="el" href="#a45354a15e70f6a2198cc43a01d3c2aa6" title="Returns a const pointer to channel i&#39;s CPU data.">channel</a> should come / from. For instance, setting r to 2 would mean that the red (0) / <a class="el" href="#a45354a15e70f6a2198cc43a01d3c2aa6" title="Returns a const pointer to channel i&#39;s CPU data.">channel</a> would be set to the current 2nd <a class="el" href="#a45354a15e70f6a2198cc43a01d3c2aa6" title="Returns a const pointer to channel i&#39;s CPU data.">channel</a>. / / In addition, the special values 4, 5, and 6 represent setting the / <a class="el" href="#a45354a15e70f6a2198cc43a01d3c2aa6" title="Returns a const pointer to channel i&#39;s CPU data.">channel</a> to a constant value of 1.0f, 0.0f, or -1.0f, respectively. <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void swizzle(int r, int g, int b, int a, TimingContext *tc = 0); / Applies a scale and bias to the given <a class="el" href="#a45354a15e70f6a2198cc43a01d3c2aa6" title="Returns a const pointer to channel i&#39;s CPU data.">channel</a>. Each value x is replaced by x * scale + bias. <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void scaleBias(int <a class="el" href="#a45354a15e70f6a2198cc43a01d3c2aa6" title="Returns a const pointer to channel i&#39;s CPU data.">channel</a>, float scale, float bias, TimingContext *tc = 0); / Clamps all values in the <a class="el" href="#a45354a15e70f6a2198cc43a01d3c2aa6" title="Returns a const pointer to channel i&#39;s CPU data.">channel</a> to the <a class="el" href="#afc8a14675ef0cbc891bfe839d29a1c29" title="Sets *rangeMin and *rangeMax to the range of values in the channel, possibly using alpha testing.">range</a> [low, high]. <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void clamp(int <a class="el" href="#a45354a15e70f6a2198cc43a01d3c2aa6" title="Returns a const pointer to channel i&#39;s CPU data.">channel</a>, float low = 0.0f, float high = 1.0f, TimingContext *tc = 0); / Interpolates all texels between their current color and a constant color <code>(r, g, b, a)</code>. / / <code>t</code> is the value used for linearly interpolating between the / surface's current colors and the constant color. For instance, a / value of <code>t=0</code> has no effect to the surface's colors, and a value / of <code>t=1</code> replaces the surface's colors entirely with (r, g, b, a). <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void blend(float r, float g, float b, float a, float t, TimingContext *tc = 0); / Converts to premultiplied alpha, replacing <code>(r, g, b, a)</code> with <code>(ar, ag, ab, a)</code>. <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void premultiplyAlpha(TimingContext *tc = 0); / Converts from premultiplied to unpremultiplied alpha, with special handling around zero alpha values. / / When <code>abs(a) &gt;= epsilon</code>, the result is the same as dividing the / RGB channels by the alpha <a class="el" href="#a45354a15e70f6a2198cc43a01d3c2aa6" title="Returns a const pointer to channel i&#39;s CPU data.">channel</a>. Otherwise, this function divides / the RGB channels by <code>epsilon * sign(a)</code>, since the result of / unpremultiplying a fully transparent color is undefined. <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void demultiplyAlpha(float epsilon = 1e-12f, TimingContext *tc = 0); / Sets channels 0...3 to the result of converting to grayscale, with customizable <a class="el" href="#a45354a15e70f6a2198cc43a01d3c2aa6" title="Returns a const pointer to channel i&#39;s CPU data.">channel</a> weights. / / For instance, this can be used to give green a higher weight than / red or blue when computing luminance. This function will normalize / the different scales so they sum to 1, so e.g. (2, 4, 1, 0) are / valid scales. The greyscale value is then computed using / <code>c / grey = r * redScale + g * greenScale + b * blueScale + a * alphaScale /</code> / and then all channels (including alpha) are set to <code>grey</code>. <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void toGreyScale(float redScale, float greenScale, float blueScale, float alphaScale, TimingContext *tc = 0); / Sets all texels on the border of the surface to a solid color. <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void setBorder(float r, float g, float b, float a, TimingContext *tc = 0); / Sets all texels in the surface to a solid color. <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void fill(float r, float g, float b, float a, TimingContext *tc = 0); / Attempts to scale the alpha <a class="el" href="#a45354a15e70f6a2198cc43a01d3c2aa6" title="Returns a const pointer to channel i&#39;s CPU data.">channel</a> so that a fraction / <code>coverage</code> (between 0 and 1) of the surface has an alpha greater / than <code>alphaRef</code>. / / </dd>
<dd>
<a class="el" href="#a3b4cdb2773ea35b42ea460a2b4026cbe" title="Returns the approximate fraction (0 to 1) of the image with an alpha value greater than alphaRef.">alphaTestCoverage()</a> for the method used to determine what fraction passes the alpha test. / </dd>
<dd>
Ignacio Casta&ntilde;o, "Computing Alpha Mipmaps" (2010) <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void scaleAlphaToCoverage(float coverage, float alphaRef = 0.5f, int alpha_channel = 3, TimingContext *tc = 0); / Produces an LDR Red, Green, Blue, Magnitude encoding of the HDR RGB channels. / / See fromRGBM() for the storage method. This uses an iterative / compression approach to reduce the error with regard to decoding. <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void toRGBM(float <a class="el" href="#afc8a14675ef0cbc891bfe839d29a1c29" title="Sets *rangeMin and *rangeMax to the range of values in the channel, possibly using alpha testing.">range</a> = 1.0f, float threshold = 0.25f, TimingContext *tc = 0); / Produces HDR <code>(r, g, b, 1)</code> values from an LDR <code>(red, green, blue, magnitude)</code> storage method. / / HDR values are reconstructed as follows: First, the magnitude <code>M</code> / is reconstructed from the alpha <a class="el" href="#a45354a15e70f6a2198cc43a01d3c2aa6" title="Returns a const pointer to channel i&#39;s CPU data.">channel</a> using / <code>M = a * (<a class="el" href="#afc8a14675ef0cbc891bfe839d29a1c29" title="Sets *rangeMin and *rangeMax to the range of values in the channel, possibly using alpha testing.">range</a> - threshold) + threshold</code>. Then the red, green, / and blue channels are multiplied by <code>M</code>. <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void fromRGBM(float <a class="el" href="#afc8a14675ef0cbc891bfe839d29a1c29" title="Sets *rangeMin and *rangeMax to the range of values in the channel, possibly using alpha testing.">range</a> = 1.0f, float threshold = 0.25f, TimingContext *tc = 0); / Stores luminance-only values in a two-channel way. Maybe consider BC4 compression instead. / / Luminance <code>L</code> is computed by averaging the red, green, and blue / values, while <code>M</code> stores the max of these values and <code>threshold</code>. / The red, green, and blue channels then store <code>L/M</code>, and the alpha / <a class="el" href="#a45354a15e70f6a2198cc43a01d3c2aa6" title="Returns a const pointer to channel i&#39;s CPU data.">channel</a> stores <code>(M - threshold)/(1 - threshold)</code>. <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void toLM(float <a class="el" href="#afc8a14675ef0cbc891bfe839d29a1c29" title="Sets *rangeMin and *rangeMax to the range of values in the channel, possibly using alpha testing.">range</a> = 1.0f, float threshold = 0.0f, TimingContext *tc = 0); / Produces a shared-exponent Red, Green, Blue, Exponent encoding of the HDR RGB channels, such as R9G9B9E5. / / <code>mantissaBits</code> and <code>exponentBits</code> must be in the <a class="el" href="#afc8a14675ef0cbc891bfe839d29a1c29" title="Sets *rangeMin and *rangeMax to the range of values in the channel, possibly using alpha testing.">range</a> 1...31. / / See fromRGBE() for the storage method. This uses an iterative / compression approach to reduce the error with regard to decoding. <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void toRGBE(int mantissaBits, int exponentBits, TimingContext *tc = 0); / Produces HDR <code>(r, g, b, 1)</code> values from an LDR <code>(red, green, blue, exponent)</code> storage method. / / HDR values are reconstructed as follows: / R, G, B, and E are first converted from UNORM floats to integers by / multiplying RGB by <code>(1 &lt;&lt; mantissaBits) - 1</code> and / E by <code>(1 &lt;&lt; exponentBits) - 1</code>. E stores a scaling factor as a / power of 2, which is reconstructed using / <code>scale = 2^(E - ((1 &lt;&lt; (exponentBits - 1)) - 1) - mantissaBits)</code>. / R, G, and B are then multiplied by <code>scale</code>. / / <code>mantissaBits</code> and <code>exponentBits</code> must be in the <a class="el" href="#afc8a14675ef0cbc891bfe839d29a1c29" title="Sets *rangeMin and *rangeMax to the range of values in the channel, possibly using alpha testing.">range</a> 1...31. <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void fromRGBE(int mantissaBits, int exponentBits, TimingContext *tc = 0); / Converts from <code>(r, g, b, -)</code> colors to <code>(Co, Cg, 1, Y)</code> colors. / / This is useful for formats that use chroma subsampling. / / Y is in the <a class="el" href="#afc8a14675ef0cbc891bfe839d29a1c29" title="Sets *rangeMin and *rangeMax to the range of values in the channel, possibly using alpha testing.">range</a> [0, 1], while Co and Cg are in the <a class="el" href="#afc8a14675ef0cbc891bfe839d29a1c29" title="Sets *rangeMin and *rangeMax to the range of values in the channel, possibly using alpha testing.">range</a> [-1, 1]. / / The RGB-to-YCoCg formula used is / <code>c / Y = (2g + r + b)/4 / Co = r - b / Cg = (2g - r - b)/2 /</code> <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void toYCoCg(TimingContext *tc = 0); / Stores per-block YCoCg scaling information for potentially better 4-<a class="el" href="#a45354a15e70f6a2198cc43a01d3c2aa6" title="Returns a const pointer to channel i&#39;s CPU data.">channel</a> compression of YCoCg <a class="el" href="#a40c605957799d4ea31682d5982e1036d" title="Returns a const pointer to the surface&#39;s CPU data.">data</a>. / / For each 4x4 block, this computes the maximum absolute Co and Cg / values, stores the result in the blue <a class="el" href="#a45354a15e70f6a2198cc43a01d3c2aa6" title="Returns a const pointer to channel i&#39;s CPU data.">channel</a>, and multiplies the / Co and Cg channels (0 and 1) by its reciprocal. The original Co / and Cg values can then be reconstructed by multiplying by the / blue <a class="el" href="#a45354a15e70f6a2198cc43a01d3c2aa6" title="Returns a const pointer to channel i&#39;s CPU data.">channel</a>. / / The scaling information is quantized to the given number of bits. / / <code>threshold</code> is ignored. / / </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This assumes that your texture compression format uses 4x4 / blocks. This is true for all BC1-BC7 formats, but ASTC can use / other block sizes. NVTT_API void blockScaleCoCg(int bits = 5, float threshold = 0.0f, TimingContext *tc = 0); / Converts from <code>(Co, Cg, scale, Y)</code> colors to <code>(r, g, b, 1)</code> colors. / / This is useful for formats that use chroma subsampling. / / Y is in the range [0, 1], while Co and Cg are in the range [-1, 1]. / Co and Cg are multiplied by channel 2 (scale) to reverse the / effects of optionally calling blockScaleCoCg(). / / The YCoCg-to-RGB formula used is / <code>c / r = Y + Co - Cg / g = Y + Cg / b = Y - Co - Cg /</code> NVTT_API void fromYCoCg(TimingContext *tc = 0); / Converts from RGB colors to a (U, V, W, L) color space, much like RGBM. / / All values are clamped to [0, 1]. Then a luminance-like value / <code>L</code> is computed from RGB using / / <code>L = max(sqrtf(R^2 + G^2 + B^2), 1e-6f)</code>. / / This then stores the value <code>(R/L, G/L, B/L, L/sqrt(3))</code>. NVTT_API void toLUVW(float range = 1.0f, TimingContext *tc = 0); / Converts from toLUVW()'s color space to RGB colors. / / This is the same as fromRGBM(range * sqrt(3)). NVTT_API void fromLUVW(float range = 1.0f, TimingContext *tc = 0); / Replaces all colors by their absolute value. NVTT_API void abs(int channel, TimingContext *tc = 0); / Convolves a channel with a kernel. / / This uses a 2D kernelSize x kernelSize kernel, with values in / <code>kernelData</code> specified in row-major order. The behavior around / image borders is determined by the image's wrap mode. NVTT_API void convolve(int channel, int kernelSize, float * kernelData, TimingContext *tc = 0); / Replaces all values with their log with the given base. NVTT_API void toLogScale(int channel, float base, TimingContext *tc = 0); / Inverts toLogScale() by replacing all values <code>x</code> with <code>base^x</code>. NVTT_API void fromLogScale(int channel, float base, TimingContext *tc = 0); / Draws borders of a given color around each w x h tile / contained within the surface, starting from the (0, 0) corner. / / In case the surface size is not divisible by the tile size, borders / are not drawn for tiles crossing the surface boundary. NVTT_API void setAtlasBorder(int w, int h, float r, float g, float b, float a, TimingContext *tc = 0); / Applies an HDR-to-LDR tone mapper. / </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenvtt.html#a30709ef62a9d666f2be7f34cce8e3b94" title="Tone mapping functions.">ToneMapper</a> for definitions of the tone mappers. <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void toneMap(<a class="el" href="namespacenvtt.html#a30709ef62a9d666f2be7f34cce8e3b94" title="Tone mapping functions.">ToneMapper</a> tm, float * parameters, TimingContext *tc = 0);</dd></dl>
<p>/ Sets values in the given channel to either 1 or 0 depending on if they're greater than the threshold, with optional dithering. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dither</td><td>If true, uses Floyd-Steinberg dithering on the CPU. Not supported for 3D surfaces. NVTT_API void binarize(int channel, float threshold, bool dither, TimingContext *tc = 0); / Quantizes this channel to a particular number of bits, with optional dithering. /</td></tr>
    <tr><td class="paramname">channel</td><td>The index of the channel to quantize. /</td></tr>
    <tr><td class="paramname">bits</td><td>The number of bits to quantize to, yielding <code>2^bits</code> possible values. / Must be nonnegative, and must not be 0 if exactEndPoints is true. /</td></tr>
    <tr><td class="paramname">exactEndPoints</td><td>If true, the set of quantized values will be / <code>0, 1/(2^bits-1), ..., 1</code>, rather than <code>0, 1/(2^bits), ..., (2^bits-1)/(2^bits)</code>. /</td></tr>
    <tr><td class="paramname">dither</td><td>If true, uses Floyd-Steinberg dithering on the CPU. Not supported for 3D surfaces. NVTT_API void quantize(int channel, int bits, bool exactEndPoints, bool dither, TimingContext *tc = 0);</td></tr>
  </table>
  </dd>
</dl>
<p>/ Sets the RGB channels to a normal map generated by interpreting the alpha channel as a heightmap, / using a blend of four small-scale to large-scale Sobel kernels. / / This uses a 9x9 kernel which is a weighted sum of a 3x3 (small), / 5x5 (medium), 7x7 (big), and 9x9 (large) differentiation kernels. / Each of the weights can be greater than 1, or even negative. / However, the kernel will be normalized so that its elements sum to / 1, so scaling should be done on the alpha channel beforehand. / The smallest kernel focuses on the highest-frequency details, and / larger kernels attenuate higher frequencies. / / The source alpha channel, which is used as a height map to / differentiate, is copied to the output. / / The output RGB channels will be in the ranges [-1, 1], [-1, 1], and [0, 1]. / / </p><dl class="section see"><dt>See also</dt><dd>convolve() <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void toNormalMap(float sm, float medium, float big, float large, TimingContext *tc = 0); / Renormalizes the elements of a signed normal map, replacing <code>(r, g, b)</code> with <code>normalize(r, g, b)</code>. / / This function is safe to call even for zero vectors. <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void normalizeNormalMap(TimingContext *tc = 0); / Applies a 3D-&gt;2D normal transformation, setting the z (blue) <a class="el" href="#a45354a15e70f6a2198cc43a01d3c2aa6" title="Returns a const pointer to channel i&#39;s CPU data.">channel</a> to 0. / / </dd>
<dd>
<a class="el" href="namespacenvtt.html#a445e3b46e43013ef66771e98f7b1e0ba" title="Specifies a normal transformation, used to store 3D (x, y, z) normals in 2D (x, y).">NormalTransform</a> for definitions of each of the normal transformations. <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void transformNormals(<a class="el" href="namespacenvtt.html#a445e3b46e43013ef66771e98f7b1e0ba" title="Specifies a normal transformation, used to store 3D (x, y, z) normals in 2D (x, y).">NormalTransform</a> xform, TimingContext *tc = 0); / Reconstructs 3D normals from 2D transformed normals. / / </dd>
<dd>
<a class="el" href="namespacenvtt.html#a445e3b46e43013ef66771e98f7b1e0ba" title="Specifies a normal transformation, used to store 3D (x, y, z) normals in 2D (x, y).">NormalTransform</a> for definitions of each of the normal transformations. <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void reconstructNormals(<a class="el" href="namespacenvtt.html#a445e3b46e43013ef66771e98f7b1e0ba" title="Specifies a normal transformation, used to store 3D (x, y, z) normals in 2D (x, y).">NormalTransform</a> xform, TimingContext *tc = 0); / Sets the z (blue) <a class="el" href="#a45354a15e70f6a2198cc43a01d3c2aa6" title="Returns a const pointer to channel i&#39;s CPU data.">channel</a> to x^2 + y^2. / / If the x and y channels represent slopes, instead of normals, then / this represents a CLEAN map. The important thing about this is that / it can be mipmapped, and the difference between the sum of the / square of the first and second mipmapped channels and the third / mipmapped <a class="el" href="#a45354a15e70f6a2198cc43a01d3c2aa6" title="Returns a const pointer to channel i&#39;s CPU data.">channel</a> can be used to determine how rough the normal / map is in a given area. / / This is a lower-memory and lower-bandwidth <a class="el" href="namespacenvtt.html#a228e276da2093484610fa62a9ec4ee93" title="Return the NVTT version number, as 10000*fork + 100*major + minor.">version</a> of LEAN mapping, / but it has the drawback that it can only represent / isotropic roughness. / / </dd>
<dd>
Olano and Baker, "LEAN Mapping", <a href="https://www.csee.umbc.edu/~olano/papers/lean/">https://www.csee.umbc.edu/~olano/papers/lean/</a> / </dd>
<dd>
Hill, "Specular Showdown in the Wild West", <a href="http://blog.selfshadow.com/2011/07/22/specular-showdown/">http://blog.selfshadow.com/2011/07/22/specular-showdown/</a> / </dd>
<dd>
<a href="http://gaim.umbc.edu/2011/07/24/shiny-and-clean/">http://gaim.umbc.edu/2011/07/24/shiny-and-clean/</a> / </dd>
<dd>
<a href="http://gaim.umbc.edu/2011/07/26/on-error/">http://gaim.umbc.edu/2011/07/26/on-error/</a> <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void toCleanNormalMap(TimingContext *tc = 0); / Packs signed normals in [-1, 1] to an unsigned <a class="el" href="#afc8a14675ef0cbc891bfe839d29a1c29" title="Sets *rangeMin and *rangeMax to the range of values in the channel, possibly using alpha testing.">range</a> [0, 1], using (r, g, b, a) |-&gt; (r/2+1/2, g/2+1/2, b/2+1/2, a). <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void packNormals(float scale = 0.5f, float bias = 0.5f, TimingContext *tc = 0); / Expands packed normals in [0, 1] to signed normals in [-1, 1] using (r, g, b, a) |-&gt; (2r-1, 2g-1, 2b-1, a). <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void expandNormals(float scale = 2.0f, float bias = -1.0f, TimingContext *tc = 0); / Unimplemented. This would equivalent to mipmapping a normal map and then measuring how much / mipmapping shortens the normals. Currently returns a null surface. / </dd>
<dd>
Hill, "Specular Showdown in the Wild West", <a href="http://blog.selfshadow.com/2011/07/22/specular-showdown/">http://blog.selfshadow.com/2011/07/22/specular-showdown/</a> <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> createToksvigMap(float power, TimingContext *tc = 0) const; / Unimplemented. Currently returns a null surface. / </dd>
<dd>
toCleanNormalMap() <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> createCleanMap(TimingContext *tc = 0) const;</dd></dl>
<p>/ Flips the surface along the X axis. NVTT_API void flipX(TimingContext *tc = 0); / Flips the surface along the Y axis. NVTT_API void flipY(TimingContext *tc = 0); / Flips the surface along the Z axis. NVTT_API void flipZ(TimingContext *tc = 0); / Creates a new surface from the range of pixels from x = x0 to x1, y = y0 to y1, and z = z0 to z1. / / If any of the parameters are out of bounds or creation fails, returns a null surface. / / A valid surface created will have size (x1 - x0 + 1) x (y1 - y0 + 1) x (z1 - z0 + 1). NVTT_API <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> createSubImage(int x0, int x1, int y0, int y1, int z0, int z1, TimingContext *tc = 0) const;</p>
<p>/ Copies channel <code>srcChannel</code> from <code>srcImage</code> to <code>srcChannel</code> of this surface. / / Returns whether the operation succeeded (for instance, it can fail / if the surfaces have different sizes). / / <code>srcChannel</code> must be in the range [0, 3]. / / The surfaces need not have the same GPU mode. NVTT_API bool copyChannel(const <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> &amp; srcImage, int srcChannel, TimingContext *tc = 0); / Copies channel <code>srcChannel</code> from <code>srcImage</code> to <code>dstChannel</code> of this surface. / / Returns whether the operation succeeded (for instance, it can fail / if the surfaces have different sizes). / / Both <code>srcChannel</code> and <code>dstChannel</code> must be in the range [0, 3]. / / The surfaces need not have the same GPU mode. NVTT_API bool copyChannel(const <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> &amp; srcImage, int srcChannel, int dstChannel, TimingContext *tc = 0); / Add channel <code>srcChannel</code> of <code>img</code>, multiplied by <code>scale</code>, to <code>dstChannel</code> of this surface. / / Returns whether the operation succeeded (for instance, it can fail / if the surfaces have different sizes). / / Both <code>srcChannel</code> and <code>dstChannel</code> must be in the range [0, 3]. / / The surfaces need not have the same GPU mode. NVTT_API bool addChannel(const <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> &amp; img, int srcChannel, int dstChannel, float scale, TimingContext *tc = 0); / Copies all channels of a rectangle from <code>src</code> to this surface. / / More specifically, this copies the rectangle / / <code>[xsrc, xsrc + xsize - 1] x [ysrc, ysrc + ysize - 1] x [zsrc, zsrc + zsize - 1]</code> / / to the rectangle / / <code>[xdst, xdst + xsize - 1] x [ydst, ydst + ysize - 1] x [zdst, zdst + zsize - 1]</code>. / / Returns whether the operation succeeded (for instance, invalid / parameters return false). NVTT_API bool copy(const <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> &amp; src, int xsrc, int ysrc, int zsrc, int xsize, int ysize, int zsize, int xdst, int ydst, int zdst, TimingContext *tc = 0);</p>
<p>/ Makes succeeding operations work on the GPU buffer. / / This also copies the surface's CPU data to a new or recreated GPU buffer. / / </p><dl class="section since"><dt>Since</dt><dd>NVTT 3.0 NVTT_API void ToGPU(TimingContext *tc = 0, bool performCopy = true); / Makes succeeding operations work on the CPU buffer. / / This copies the surface's GPU buffer to the CPU buffer, then destroys the GPU buffer. / / </dd>
<dd>
NVTT 3.0 NVTT_API void ToCPU(TimingContext *tc = 0); / Get a CUDA pointer to const image data on the GPU, using the same layout as <a class="el" href="#acad4388ee26550c4aae145b99d0ac563" title="Returns a pointer that can be used to modify the surface&#39;s CPU data. See data() const.">data()</a>. / If GPU data does not exist, returns <code>nullptr</code>. NVTT_API const float * gpuData() const; / Get a CUDA pointer to non-const image data on the GPU, using the same layout as <a class="el" href="#acad4388ee26550c4aae145b99d0ac563" title="Returns a pointer that can be used to modify the surface&#39;s CPU data. See data() const.">data()</a>. / If GPU data does not exist, returns <code>nullptr</code>. / This can be used to modify NVTT <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> data on the GPU, outside of / the functions NVTT provides. / </dd>
<dd>
NVTT 3.2 NVTT_API float * gpuDataMutable();</dd></dl>
<p>private: void detach();</p>
<p>struct Private; Private * m; };</p>
<p>/ Surface-set struct for convenience of handling multi-level texture files such as DDS, currently only supporting reading. / </p><dl class="section since"><dt>Since</dt><dd>NVTT 3.0 <br  />
 struct SurfaceSet {</dd></dl>
<p>/ Constructor NVTT_API SurfaceSet(); / Destructor NVTT_API ~SurfaceSet();</p>
<p>/ Texture type: 2D, 3D, or Cube NVTT_API TextureType GetTextureType(); / Number of faces NVTT_API int GetFaceCount(); / Number of mip-map levels NVTT_API int GetMipmapCount(); / Image width (level 0) NVTT_API int GetWidth(); / Image height (level 0) NVTT_API int GetHeight(); / Image depth (level 0) NVTT_API int GetDepth();</p>
<p>/ Get a surface at specified face and mip level NVTT_API <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> GetSurface(int faceId, int mipId, bool expectSigned = false);</p>
<p>/ Get a surface at specified face and mip level NVTT_API void GetSurface(int faceId, int mipId, <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a>&amp; surface, bool expectSigned = false);</p>
<p>/ Release data NVTT_API void reset();</p>
<p>/ Load a surface set from a DDS file. / </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if loading succeeded and <code>false</code> if it failed. / /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>Path to the file to load. This uses the same / character encoding as the <code>filename</code> argument of <code>fopen()</code>. /</td></tr>
    <tr><td class="paramname">forcenormal</td><td>If true, builds a normal map from the red and / green components of BC5U data, or the alpha and green components of / BC3 data. NVTT_API bool loadDDS(const char * fileName, bool forcenormal = false);</td></tr>
  </table>
  </dd>
</dl>
<p>/ Load a surface set from an in-memory DDS file. / </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if loading succeeded and <code>false</code> if it failed. / /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to the start of the file's data in memory. /</td></tr>
    <tr><td class="paramname">sizeInBytes</td><td>Length of the file's data. /</td></tr>
    <tr><td class="paramname">forcenormal</td><td>If true, builds a normal map from the red and / green components of BC5U data, or the alpha and green components of / BC3 data. NVTT_API bool loadDDSFromMemory(const void * data, unsigned long long sizeInBytes, bool forcenormal = false);</td></tr>
  </table>
  </dd>
</dl>
<p>/ Save an image at specified face and mip level (for decompression) NVTT_API bool saveImage(const char* fileName, int faceId, int mipId);</p>
<p>};</p>
<p>/ Specifies how to fold or unfold a cube map from or to a 2D texture. / </p><dl class="section since"><dt>Since</dt><dd>NVTT 2.1 enum CubeLayout { / Unfolds into a 3*edgeLength (width) x 4*edgeLength texture, laid / out as follows: / <code>text / 2 / 140 / 3 / 5 /</code> / Face 5 is rotated 180 degrees. CubeLayout_VerticalCross, / Unfolds into a 4*edgeLength (width) x 3*edgeLength texture, laid / out as follows: / <code>text / 2 / 1405 / 3 /</code> / Face 5 is rotated 180 degrees. CubeLayout_HorizontalCross, / Writes each face in order into a column layout, like this: / <code>text / 0 / 1 / 2 / 3 / 4 / 5 /</code> CubeLayout_Column, / Writes each face in order into a row layout, like this: / <code>text / 012345 /</code> CubeLayout_Row, / Same as CubeLayout_VerticalCross. CubeLayout_LatitudeLongitude };</dd></dl>
<p>/ Use EdgeFixup_None if unsure; this affects how certain cube surface processing algorithms work. enum EdgeFixup { EdgeFixup_None, ///&lt; No effect. EdgeFixup_Stretch, ///&lt; Slightly stretches and shifts the coordinate systems cosinePowerFilter() and fastResample() use. EdgeFixup_Warp, ///&lt; Applies a cubic warp to each face's coordinate system in cosinePowerFilter() and fastResample(), warping texels closer to edges more. EdgeFixup_Average, ///&lt; Currently unimplemented. };</p>
<p>/ A CubeSurface is one level of a cube map texture. / / CubeSurfaces are either null, or contain six square Surfaces numbered / 0 through 5, all with the same size (referred to as the edge length). / By convention, these are the +x, -x, +y, -y, +z, and -z faces, in that / order, of a cube map in a right-handed coordinate system. / / These objects are reference-counted like <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">nvtt::Surface</a>. / / </p><dl class="section since"><dt>Since</dt><dd>NVTT 2.1 struct CubeSurface { / Creates a null CubeSurface. NVTT_API CubeSurface(); / Copy constructor. NVTT_API CubeSurface(const CubeSurface &amp; img); / Destructor. NVTT_API ~CubeSurface(); / Assignment operator. NVTT_API void operator=(const CubeSurface &amp; img);</dd></dl>
<p>/ Returns if this CubeSurface is null (i.e. has no underlying / data, or all faces have size 0x0). NVTT_API bool <a class="el" href="#a3d06b99f9298acdcac222e8c48d49a0b" title="Returns if the surface is null (i.e. refers to nothing, such as if it was just created using Surface(...">isNull() const</a>; / Returns the edge length of any of the faces. NVTT_API int edgeLength() const; / Returns the number of mips that would be in a full mipmap / chain starting with this CubeSurface. / / For instance, a full mip chain for a cube map with 10x10 faces / would consist of cube maps with sizes 10x10, 5x5, 2x2, and 1x1, and / this function would return 4. NVTT_API int <a class="el" href="#a9d4de8d67b1fb1ac8a96ff1af239b436" title="Returns the number of mipmaps in a full mipmap chain. Each mip is half the size of the previous,...">countMipmaps() const</a>;</p>
<p>/ Load a cube map from a DDS file. / /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>Path to the file to load. This uses the same / character encoding as the <code>filename</code> argument of <code>fopen()</code>. /</td></tr>
    <tr><td class="paramname">mipmap</td><td>The mip to read. If <code>mipmap</code> is negative, then this / reads the <code>abs(mipmap)</code>'th smallest mipmap. / / If the DDS file has multiple array elements, this always loads the first one. / / Returns whether the operation succeeded (for instance, this can / fail if the file does not exist or if the mipmap was out of range). NVTT_API bool load(const char * fileName, int mipmap); / Load a cube map from a DDS file in memory. / /</td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the start of the file's data in memory. /</td></tr>
    <tr><td class="paramname">sizeInBytes</td><td>Length of the file's data. /</td></tr>
    <tr><td class="paramname">mipmap</td><td>The mip to read. If <code>mipmap</code> is negative, then this / reads the <code>abs(mipmap)</code>'th smallest mipmap. / / If the DDS file has multiple array elements, this always loads the first one. / / Returns whether the operation succeeded (for instance, this can / fail if the file does not exist or if the mipmap was out of range). NVTT_API bool loadFromMemory(const void * data, unsigned long long sizeInBytes, int mipmap); / Save a cube map to a DDS file in memory. / / Unimplemented - iterate over faces and save them instead. NVTT_API bool save(const char * fileName) const;</td></tr>
  </table>
  </dd>
</dl>
<p>/ Get a non-const reference to the surface for the given face. / / <code>face</code> must be in the range [0, 5]. NVTT_API <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> &amp; face(int face); / Get a const reference to the surface for the given face. / / <code>face</code> must be in the range [0, 5]. NVTT_API const <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> &amp; face(int face) const;</p>
<p>/ Sets this CubeSurface from a 2D unfolded surface in <code>img</code>. / / </p><dl class="section see"><dt>See also</dt><dd>#CubeLayout for allowed folding layouts. <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void fold(const Surface &amp; img, CubeLayout layout); / Creates a <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> containing an unfolded/flattened representation of the cube surface. / / </dd>
<dd>
#CubeLayout for allowed folding layouts. <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> unfold(CubeLayout layout) const;</dd></dl>
<p>@ Angular extent filtering.</p>
<p>@ Add resizing methods.</p>
<p>@ Add edge fixup methods.</p>
<p>/ Computes an average value for the given channel over the entire sphere. / / This takes solid angles into account when producing an average per / steradian, so texels near face edges are weighted less than texels / near face edges. / / No gamma correction is performed, unlike <a class="el" href="#ae9ed55dcc5f3f3d297e02872164be2d5" title="Computes the average of a channel, possibly with alpha or with a gamma transfer function.">nvtt::Surface::average()</a>. NVTT_API float average(int channel) const; / Sets <code>*minimum_ptr</code> and <code>*maximum_ptr</code> to the minimum and / maximum values in the given channel. / / If all faces have size 0 x 0 (in which case the cube surface <a class="el" href="#a3d06b99f9298acdcac222e8c48d49a0b" title="Returns if the surface is null (i.e. refers to nothing, such as if it was just created using Surface(...">isNull()</a>), / this will set <code>*minimum_ptr</code> to <code>FLT_MAX</code> and <code>*maximum_ptr</code> to 0.0f. NVTT_API void range(int channel, float * minimum_ptr, float * maximum_ptr) const; / Clamps values in the given channel to the range [low, high]. NVTT_API void clamp(int channel, float low = 0.0f, float high = 1.0f);</p>
<p>/ Unimplemented; returns a null CubeSurface. NVTT_API CubeSurface irradianceFilter(int size, EdgeFixup fixupMethod) const; / Spherically convolves this CubeSurface with a / <code>max(0.0f, cos(theta))^cosinePower</code> kernel, returning a CubeSurface / with faces with dimension size x size. / / This is useful for generating prefiltered cube maps, as this / corresponds to the cosine power used in the Phong reflection model / (with energy conservation). / / This handles how each cube map texel can have a different solid angle. / It also only considers texels for which the value of the kernel / (without normalization) is at least 0.001. NVTT_API CubeSurface cosinePowerFilter(int size, float cosinePower, EdgeFixup fixupMethod) const; / Produces a resized version of this CubeSurface using nearest-neighbor sampling. NVTT_API CubeSurface fastResample(int size, EdgeFixup fixupMethod) const;</p>
<p>/ Raises channels 0...2 to the power <code>gamma</code>. / / Using a <code>gamma</code> of 2.2 approximates sRGB-to-linear conversion. / / </p><dl class="section see"><dt>See also</dt><dd>nvtt::Surface::toLinear() <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void toLinear(float gamma); / Raises channels 0...2 to the power <code>1/gamma</code>. / / Using a <code>gamma</code> of 2.2 approximates linear-to-sRGB conversion. / / </dd>
<dd>
nvtt::Surface::toGamma() <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97" title="Functions with this macro are accessible via the NVTT DLL.">NVTT_API</a> void toGamma(float gamma);</dd></dl>
<p>private: void detach();</p>
<p>struct Private; Private * m; };</p>
<p>/ Structure defining a list of inputs to be compressed. / / Inputs will be combined for parallel GPU processing. / Better performance expected comparing to the Surface-only API, which compresses each image one by one, especially when the images are small. / / </p><dl class="section since"><dt>Since</dt><dd>NVTT 3.0 struct BatchList {</dd></dl>
<p>/ Creates an empty BatchList. NVTT_API BatchList(); / Destructor. NVTT_API ~BatchList(); / Clears the list of inputs in this BatchList. NVTT_API void Clear(); / Adds a pointer to the surface, its face and mipmap index, and a pointer to the output method to the input list. NVTT_API void Append(const Surface* pImg, int face, int mipmap, const OutputOptions* outputOptions);</p>
<p>/ Returns the size of the input list. NVTT_API unsigned GetSize() const; / Gets the <code>i</code>th item in the input list. NVTT_API void GetItem(unsigned i, const Surface*&amp; pImg, int&amp; face, int&amp; mipmap, const OutputOptions*&amp; outputOptions) const;</p>
<p>};</p>
<p>/ Image comparison and error measurement functions. (New in NVTT 2.1) NVTT_API float rmsError(const <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> &amp; reference, const <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> &amp; img, TimingContext *tc = 0); / Image comparison and error measurement functions. (New in NVTT 2.1) NVTT_API float rmsAlphaError(const <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> &amp; reference, const <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> &amp; img, TimingContext *tc = 0); / Image comparison and error measurement functions. (New in NVTT 2.1) NVTT_API float cieLabError(const <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> &amp; reference, const <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> &amp; img, TimingContext *tc = 0); / Image comparison and error measurement functions. (New in NVTT 2.1) NVTT_API float angularError(const <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> &amp; reference, const <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> &amp; img, TimingContext *tc = 0); / Image comparison and error measurement functions. (New in NVTT 2.1) NVTT_API <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> diff(const <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> &amp; reference, const <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> &amp; img, float scale, TimingContext *tc = 0);</p>
<p>/ Image comparison and error measurement functions. (New in NVTT 2.1) NVTT_API float rmsToneMappedError(const <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> &amp; reference, const <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> &amp; img, float exposure, TimingContext *tc = 0);</p>
<p>/ Generate histogram from surface NVTT_API <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> histogram(const <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> &amp; img, int width, int height, TimingContext *tc = 0);</p>
<p>/ Generate histogram from surface NVTT_API <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> histogram(const <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> &amp; img, float minRange, float maxRange, int width, int height, TimingContext *tc = 0);</p>
<p>/ Geting the target extent for round-mode and texture-type. (New in NVTT 3.0) NVTT_API void getTargetExtent(int * width, int * height, int * depth, int maxExtent, RoundMode roundMode, TextureType textureType, TimingContext *tc = 0);</p>
<p>/ Calculate the count of mipmaps given width, height, depth. (New in NVTT 3.0) NVTT_API int countMipmaps(int w, int h, int d, TimingContext *tc = 0);</p>
<p>/ A TimingContext is a way to collect timing data from a number of / functions, and report how much time each function took. / / Since NVTT 3.0, many functions will take an optional TimingContext / pointer. If the <code>detailLevel</code> of the TimingContext is high enough, / the function will record the function name and how much CPU time the / function took, synchronizing with the CPU if necessary. One can then / get individual records using <a class="el" href="#a2ecbc4dfdfcf7e02d3b94c536ebb4a83" title="Returns whether a the surface would have a next mip in a mip chain with minimum size min_size....">GetRecord()</a>, or print all statistics / using <a class="el" href="#aa9324376c151d2aa91b23c402e150efe" title="Prints all records including their levels of nesting.">PrintRecords()</a>. / / </p><dl class="section since"><dt>Since</dt><dd>NVTT 3.0 struct TimingContext { / Creates a TimingContext with the given <code>detailLevel</code>. / / Functions will only collect timing data if their detail level / (usually 2 or 3) is less than or equal to the TimingContext's / <code>detailLevel</code>. NVTT_API TimingContext(int detailLevel = 1); / Destructor. NVTT_API ~TimingContext();</dd></dl>
<p>/ Sets this TimingContext's detail level. / / Functions will only collect timing data if their detail level / (usually 2 or 3) is less than or equal to the TimingContext's / <code>detailLevel</code>. NVTT_API void SetDetailLevel(int detailLevel);</p>
<p>/ Returns the number of timing records stored. NVTT_API int GetRecordCount(); / Returns the description and length in seconds of the <code>i</code>th record. / / </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated</a></b></dt><dd>GetRecord(int, char*, double&amp;) doesn't check the length / of its description argument before copying an arbitrary-length / string into it. Please use <a class="el" href="#a2ecbc4dfdfcf7e02d3b94c536ebb4a83" title="Returns whether a the surface would have a next mip in a mip chain with minimum size min_size....">GetRecord(int, char*, size_t, double&amp;)</a> / instead. / / The description is strcopied directly into <code>description</code>, which must be long enough. NVTT_DEPRECATED_API void GetRecord(int i, char* description, double&amp; seconds); /</dd></dl>
<p>Returns the description and length in seconds of the <code>i</code>th record. / / <code>outDescriptionSize</code> is the size in bytes of the buffer pointed to / by <code>outDescription</code>. <a class="el" href="#a2ecbc4dfdfcf7e02d3b94c536ebb4a83" title="Returns whether a the surface would have a next mip in a mip chain with minimum size min_size....">GetRecord()</a> truncates (if necessary) the / record's description to <code>outDescriptionSize-1</code> bytes, and always / writes a null terminator. / / Returns the number of bytes written, / not including the null terminator. / If <code>outDescription</code> is null, returns the number of bytes in the / record's description. / If <code>i</code> is out of bounds, returns 0. </p>

</div>
</div>
<a id="a315247163465480bfc38c9a63a4f4e3a" name="a315247163465480bfc38c9a63a4f4e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315247163465480bfc38c9a63a4f4e3a">&#9670;&#160;</a></span>histogram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::histogram </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>channel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>rangeMin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>rangeMax</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>binCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>binPtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TimingContext *</td>          <td class="paramname"><span class="paramname"><em>tc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores a histogram of channel values between <code>rangeMin</code> and <code>rangeMax</code> into <code>binPtr[0...binCount-1]</code>. </p>
<p><code>binPtr</code> must be an array of at least <code>binCount</code> integers. This function does not clear <code>binPtr</code>'s values, in case we want to accumulate multiple histograms.</p>
<p>Each texel's value is linearly mapped to a bin, using floor rounding. Values below <code>rangeMin</code> are clamped to bin 0, values above <code>rangeMax</code> are clamped to bin <code>binCount-1</code>. Then the bin's value is incremented. </p>

</div>
</div>
<a id="a7162b072976c0134a3854df107c2b7d5" name="a7162b072976c0134a3854df107c2b7d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7162b072976c0134a3854df107c2b7d5">&#9670;&#160;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool nvtt::Surface::load </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fileName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>hasAlpha</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>expectSigned</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TimingContext *</td>          <td class="paramname"><span class="paramname"><em>tc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads texture data from a file. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if loading succeeded and <code>false</code> if it failed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>Path to the file to load. This uses the same character encoding as the <code>filename</code> argument of <code>fopen()</code>. </td></tr>
    <tr><td class="paramname">hasAlpha</td><td>If this is non-null, then <code>*hasAlpha</code> will be set to whether the reader reported that the file included an alpha channel. </td></tr>
    <tr><td class="paramname">expectSigned</td><td>If this is true, then some forms of unsigned data will be converted to signed using the mapping x |-&gt; 2x-1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a779543e6e00e503a8734b1281ff25b5b" name="a779543e6e00e503a8734b1281ff25b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a779543e6e00e503a8734b1281ff25b5b">&#9670;&#160;</a></span>loadFromMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool nvtt::Surface::loadFromMemory </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long</td>          <td class="paramname"><span class="paramname"><em>sizeInBytes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>hasAlpha</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>expectSigned</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TimingContext *</td>          <td class="paramname"><span class="paramname"><em>tc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variant of <a class="el" href="#a7162b072976c0134a3854df107c2b7d5" title="Loads texture data from a file.">load()</a> that reads from memory instead of a file. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if loading succeeded and <code>false</code> if it failed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to the start of the file's data in memory. </td></tr>
    <tr><td class="paramname">sizeInBytes</td><td>Length of the file's data. </td></tr>
    <tr><td class="paramname">hasAlpha</td><td>If this is non-null, then <code>*hasAlpha</code> will be set to whether the reader reported that the file included an alpha channel. </td></tr>
    <tr><td class="paramname">expectSigned</td><td>If this is true, then some forms of unsigned data will be converted to signed using the mapping x |-&gt; 2x-1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9324376c151d2aa91b23c402e150efe" name="aa9324376c151d2aa91b23c402e150efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9324376c151d2aa91b23c402e150efe">&#9670;&#160;</a></span>PrintRecords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::PrintRecords </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints all records including their levels of nesting. </p>
<p>NVTT keeps track of how deeply timers are nested, so this will print out each description and length with an indentation corresponding to its nesting depth. </p>

</div>
</div>
<a id="afc8a14675ef0cbc891bfe839d29a1c29" name="afc8a14675ef0cbc891bfe839d29a1c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8a14675ef0cbc891bfe839d29a1c29">&#9670;&#160;</a></span>range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::range </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>channel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>rangeMin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>rangeMax</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>alpha_channel</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>alpha_ref</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TimingContext *</td>          <td class="paramname"><span class="paramname"><em>tc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <code>*rangeMin</code> and <code>*rangeMax</code> to the range of values in the channel, possibly using alpha testing. </p>
<p>If <code>alpha_channel</code> is -1, this sets <code>*rangeMin</code> to the smallest value in the entire channel, and <code>*rangeMax</code> to the largest value in the entire channel. Otherwise, this only includes texels for which the alpha value is greater than <code>alpha_ref</code>.</p>
<p>If the image is null or if an alpha channel is selected and all texels fail the alpha test, this sets <code>*rangeMin</code> to <code>FLT_MAX</code> and <code>*rangeMax</code> to <code>FLT_MIN</code>, i.e. one will have <code>*rangeMin &gt; *rangeMax</code>. </p>

</div>
</div>
<a id="a6f66cd503c0b7fd8667cfc7acca170e4" name="a6f66cd503c0b7fd8667cfc7acca170e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f66cd503c0b7fd8667cfc7acca170e4">&#9670;&#160;</a></span>resize() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::resize </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxExtent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenvtt.html#a673a22796ec42ae50e14ab1ed6906bd5">RoundMode</a></td>          <td class="paramname"><span class="paramname"><em>mode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7">ResizeFilter</a></td>          <td class="paramname"><span class="paramname"><em>filter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>filterWidth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *</td>          <td class="paramname"><span class="paramname"><em>params</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TimingContext *</td>          <td class="paramname"><span class="paramname"><em>tc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes this surface so that its largest side has length <code>maxExtent</code>, subject to a rounding mode, using customizable filter parameters. </p>
<dl class="section see"><dt>See also</dt><dd>getTargetExtent() </dd></dl>

</div>
</div>
<a id="ac459aa4c41f41ec0f615b6352e3262c2" name="ac459aa4c41f41ec0f615b6352e3262c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac459aa4c41f41ec0f615b6352e3262c2">&#9670;&#160;</a></span>resize() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::resize </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxExtent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenvtt.html#a673a22796ec42ae50e14ab1ed6906bd5">RoundMode</a></td>          <td class="paramname"><span class="paramname"><em>mode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7">ResizeFilter</a></td>          <td class="paramname"><span class="paramname"><em>filter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TimingContext *</td>          <td class="paramname"><span class="paramname"><em>tc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes this surface so that its largest side has length <code>maxExtent</code>, subject to a rounding mode. </p>
<dl class="section see"><dt>See also</dt><dd>getTargetExtent() </dd></dl>

</div>
</div>
<a id="a013d651c695516e8fdbdf7634573918a" name="a013d651c695516e8fdbdf7634573918a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a013d651c695516e8fdbdf7634573918a">&#9670;&#160;</a></span>resize() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::resize </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7">ResizeFilter</a></td>          <td class="paramname"><span class="paramname"><em>filter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>filterWidth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *</td>          <td class="paramname"><span class="paramname"><em>params</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TimingContext *</td>          <td class="paramname"><span class="paramname"><em>tc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resizes this surface using customizable filter parameters.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7" title="Texture resizing filters.">ResizeFilter</a> for filter-specific parameters. </dd></dl>

</div>
</div>
<a id="af84c67783861084298893fa54f031624" name="af84c67783861084298893fa54f031624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84c67783861084298893fa54f031624">&#9670;&#160;</a></span>resize_make_square()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::resize_make_square </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxExtent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenvtt.html#a673a22796ec42ae50e14ab1ed6906bd5">RoundMode</a></td>          <td class="paramname"><span class="paramname"><em>roundMode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7">ResizeFilter</a></td>          <td class="paramname"><span class="paramname"><em>filter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TimingContext *</td>          <td class="paramname"><span class="paramname"><em>tc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes this surface so that its longest side has length <code>maxExtent</code> and the result is square or cubical. </p>
<p>For 2D surfaces, the size is determined using getTargetExtent(), then using the minimum of the width and height. For 3D surfaces, the size is similarly determined using getTargetExtent(), then using the minimum of the width, height, or depth. </p>

</div>
</div>
<a id="a103d5b57c7153ceb77f23a3d9714c706" name="a103d5b57c7153ceb77f23a3d9714c706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a103d5b57c7153ceb77f23a3d9714c706">&#9670;&#160;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool nvtt::Surface::save </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fileName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>hasAlpha</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>hdr</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TimingContext *</td>          <td class="paramname"><span class="paramname"><em>tc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves texture data to file. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if saving succeeded and <code>false</code> if it failed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>Path to the file to load. This uses the same character encoding as the <code>filename</code> argument of <code>fopen()</code>. </td></tr>
    <tr><td class="paramname">hasAlpha</td><td>If true, then TGA images will be saved with an alpha channel. </td></tr>
    <tr><td class="paramname">hdr</td><td>If true, then this will attempt to use a writer that supports an HDR format before attempting to use an LDR format writer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1f88d67c313490b2ed042c240b718c2" name="ab1f88d67c313490b2ed042c240b718c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f88d67c313490b2ed042c240b718c2">&#9670;&#160;</a></span>setImage() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool nvtt::Surface::setImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenvtt.html#a7ea4cd82d5104d66e14f5524442c5f5e">InputFormat</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>unsignedToSigned</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TimingContext *</td>          <td class="paramname"><span class="paramname"><em>tc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this surface given uncompressed input data. </p>
<p>The type of values in <code>data</code> should match <code>format</code>.</p>
<p>If <code>unsignedToSigned</code> is true, <a class="el" href="namespacenvtt.html#a7ea4cd82d5104d66e14f5524442c5f5eaf8b3af0719535e2e45599d0b20a463d2" title="[0, 255] 8 bit uint">InputFormat_BGRA_8UB</a> unsigned input will be converted to signed values between -1 and 1, mapping 0 to -1, and 1...255 linearly to -1...1.</p>
<p>Returns whether setting the image succeeded.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a5a47935fcb94952c439aa5a4e4d4f498" title="Sets this surface to a new w x h x d uninitialized image.">setImage(int, int, int, TimingContext*)</a> </dd></dl>

</div>
</div>
<a id="a6575c5667cd8654ee9d224075f5e3576" name="a6575c5667cd8654ee9d224075f5e3576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6575c5667cd8654ee9d224075f5e3576">&#9670;&#160;</a></span>setImage() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool nvtt::Surface::setImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenvtt.html#a7ea4cd82d5104d66e14f5524442c5f5e">InputFormat</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TimingContext *</td>          <td class="paramname"><span class="paramname"><em>tc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this surface given uncompressed input data, with different pointers for each channel. </p>
<p>The type of values in <code>data</code> should match <code>format</code>.</p>
<p>Returns whether setting the image succeeded.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a5a47935fcb94952c439aa5a4e4d4f498" title="Sets this surface to a new w x h x d uninitialized image.">setImage(int, int, int, TimingContext*)</a> </dd></dl>

</div>
</div>
<a id="a5a47935fcb94952c439aa5a4e4d4f498" name="a5a47935fcb94952c439aa5a4e4d4f498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a47935fcb94952c439aa5a4e4d4f498">&#9670;&#160;</a></span>setImage() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool nvtt::Surface::setImage </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TimingContext *</td>          <td class="paramname"><span class="paramname"><em>tc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this surface to a new w x h x d uninitialized image. </p>
<p>Surfaces are not GPU-enabled by default. The surface's texture type will be set to TextureType_2D if <code>d == 1</code>, and TextureType_3D otherwise. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> </dd></dl>

</div>
</div>
<a id="a2aed8c61f05336b7eab8b2e1431ccc65" name="a2aed8c61f05336b7eab8b2e1431ccc65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aed8c61f05336b7eab8b2e1431ccc65">&#9670;&#160;</a></span>setImage3D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool nvtt::Surface::setImage3D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6d">Format</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TimingContext *</td>          <td class="paramname"><span class="paramname"><em>tc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set surface values from an encoded data source. </p>
<p>For instance, this can be used to decompress BC1-BC7 or ASTC data.</p>
<p>Returns whether setting the image succeeded. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>nvtt/<a class="el" href="nvtt_8h_source.html">nvtt.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
